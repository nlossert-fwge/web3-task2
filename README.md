## 任务详解

### Task 1: 指针和切片操作
**文件**: `task1.go`  
**考察点**: 指针传递、切片引用传递

- `intadd10()`: 通过指针修改整数值，演示指针传递
- `intmul2()`: 修改切片元素，演示切片的引用特性

**运行方式**:
```bash
go run task1.go
```

### Task 2: 协程和WaitGroup
**文件**: `task2.go`  
**考察点**: 协程并发、WaitGroup同步、闭包

- 并发执行奇数和偶数打印任务
- 使用WaitGroup等待所有协程完成
- 统计每个任务的执行时间

**运行方式**:
```bash
go run task2.go
```

### Task 3: 接口和多态
**文件**: `task3.go`  
**考察点**: 接口定义、方法实现、多态性

- 定义`Shape`接口，包含`Area()`和`Perimeter()`方法
- `Rectangle`和`Circle`结构体实现接口
- 演示多态性和接口的使用

**运行方式**:
```bash
go run task3.go
```

### Task 4: 结构体嵌套
**文件**: `task4.go`  
**考察点**: 结构体嵌套、方法定义

- `Person`基础结构体
- `Employee`嵌套`Person`结构体
- 演示结构体组合和方法调用

**运行方式**:
```bash
go run task4.go
```

### Task 5: 通道方向性
**文件**: `task5.go`  
**考察点**: 通道方向性、并发通信

- 只读通道`<-chan int`
- 只写通道`chan<- int`
- 演示通道的方向性约束和并发通信

**运行方式**:
```bash
go run task5.go
```

### Task 6: 互斥锁并发控制
**文件**: `task6.go`  
**考察点**: 互斥锁、并发数据安全

- 使用`sync.Mutex`保护共享资源
- 10个协程并发递增计数器
- 演示互斥锁解决数据竞争问题

**运行方式**:
```bash
go run task6.go
```

### Task 7: 原子操作无锁计数器
**文件**: `task7.go`  
**考察点**: 原子操作、无锁并发编程

- 使用`sync/atomic`包实现无锁计数器
- 10个协程并发执行10000次递增操作
- 演示原子操作的高性能并发控制

**运行方式**:
```bash
go run task7.go
```

## 技术要点总结

### 1. 内存管理
- **指针传递**: 直接修改原始数据
- **切片引用**: 切片底层数组的共享特性

### 2. 并发编程
- **协程(Goroutine)**: 轻量级线程
- **WaitGroup**: 协程同步机制
- **互斥锁(Mutex)**: 传统的并发控制方式
- **原子操作(Atomic)**: 高性能的无锁并发控制

### 3. 通道(Channel)
- **方向性**: 只读/只写通道约束
- **并发通信**: "不要通过共享内存来通信，而要通过通信来共享内存"

### 4. 面向对象特性
- **接口(Interface)**: 定义行为契约
- **多态性**: 不同类型实现相同接口
- **结构体嵌套**: 组合优于继承

## 运行环境要求

- Go 1.16 或更高版本
- 支持并发的操作系统

## 性能对比

| 并发控制方式 | 文件 | 特点 | 性能 |
|-------------|------|------|------|
| 互斥锁 | task6.go | 传统锁机制 | 中等 |
| 原子操作 | task7.go | 无锁机制 | 高 |

原子操作通常比互斥锁有更好的性能，特别是在高并发场景下。